<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LombScargle</title><meta name="title" content="Home · LombScargle"/><meta property="og:title" content="Home · LombScargle"/><meta property="twitter:title" content="Home · LombScargle"/><meta name="description" content="Documentation for LombScargle."/><meta property="og:description" content="Documentation for LombScargle."/><meta property="twitter:description" content="Documentation for LombScargle."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LombScargle</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Development"><span>Development</span></a></li><li><a class="tocitem" href="#License"><span>License</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAstro/LombScargle.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAstro/LombScargle.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LombScargle.jl"><a class="docs-heading-anchor" href="#LombScargle.jl">LombScargle.jl</a><a id="LombScargle.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LombScargle.jl" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><a href="https://github.com/JuliaAstro/LombScargle.jl"><code>LombScargle.jl</code></a> is a package for a fast multi-threaded estimation of the <a href="https://en.wikipedia.org/wiki/Frequency_spectrum">frequency spectrum</a> of a periodic signal with <a href="https://en.wikipedia.org/wiki/The_Lomb–Scargle_periodogram">the Lomb–Scargle periodogram</a>.  This is written in <a href="http://julialang.org/">Julia</a>, a modern high-level, high-performance dynamic programming language designed for technical computing.</p><p>Another Julia package that provides tools to perform spectral analysis of signals is <a href="https://github.com/JuliaDSP/DSP.jl">DSP.jl</a>, but its methods require that the signal has been sampled at equally spaced times. Instead, the Lomb–Scargle periodogram enables you to analyze unevenly sampled data as well, which is a fairly common case in astronomy, a field where this periodogram is widely used.</p><p>The algorithms used in this package are reported in the following papers:</p><div class="citation noncanonical"><ul><li><div>Press, W. H. and Rybicki, G. B. (1989). <em>Fast Algorithm for Spectral Analysis of Unevenly Sampled Data</em>. <a href="https://doi.org/10.1086/167197">The Astrophysical Journal <strong>338</strong>, 277</a>.</div></li><li><div>Townsend, R. H. (2010). <a href="https://dx.doi.org/10.1088/0067-0049/191/2/247"><em>Fast Calculation of the Lomb–Scargle Periodogram Using Graphics Processing Units</em></a>. <a href="https://doi.org/10.1088/0067-0049/191/2/247">The Astrophysical Journal Supplement Series <strong>191</strong>, 247</a>.</div></li><li><div>Zechmeister, M. and Kürster, M. (2009). <em>The generalised Lomb-Scargle periodogram: A new formalism for the floating-mean and Keplerian periodograms</em>. <a href="https://doi.org/10.1051/0004-6361:200811296">Astronomy &amp; Astrophysics <strong>496</strong>, 577–584</a>, <a href="https://arxiv.org/abs/0901.2573">arXiv:0901.2573 [astro-ph.IM]</a>.</div></li></ul></div><p>Other relevant papers are:</p><div class="citation noncanonical"><ul><li><div>Cumming, A. (2004). <em>Detectability of extrasolar planets in radial velocity surveys</em>. <a href="https://doi.org/10.1111/j.1365-2966.2004.08275.x">Monthly Notices of the Royal Astronomical Society <strong>354</strong>, 1165–1176</a>, <a href="https://arxiv.org/abs/astro-ph/0408470">arXiv:astro-ph/0408470 [astro-ph]</a>.</div></li><li><div>Cumming, A.; Marcy, G. W. and Butler, R. P. (1999). <em>The Lick Planet Search: Detectability and Mass Thresholds</em>. <a href="https://doi.org/10.1086/308020">The Astrophysical Journal <strong>526</strong>, 890–915</a>, <a href="https://arxiv.org/abs/astro-ph/9906466">arXiv:astro-ph/9906466 [astro-ph]</a>.</div></li><li><div>Horne, J. and Baliunas, S. (1986). <em>A Prescription for Period Analysis of Unevenly Sampled Time Series</em>. <a href="https://doi.org/10.1086/164037">The Astrophysical Journal <strong>302</strong>, 757</a>.</div></li><li><div>Lomb, N. (1976). <em>Least-Squares Frequency Analysis of Unequally Spaced Data</em>. <a href="https://doi.org/10.1007/BF00648343">Astrophysics and Space Science <strong>39</strong>, 447–462</a>.</div></li><li><div>Murdoch, K. A.; Hearnshaw, J. and Clark, M. (1993). <em>A Search for Substellar Companions to Southern Solar-Type Stars</em>. <a href="https://doi.org/10.1086/173003">The Astrophysical Journal <strong>413</strong>, 349</a>.</div></li><li><div>Scargle, J. (1982). <em>Studies in astronomical time series analysis. II. Statistical aspects of spectral analysis of unevenly spaced data.</em> <a href="https://doi.org/10.1086/160554">The Astrophysical Journal <strong>263</strong>, 835–853</a>.</div></li><li><div>Sturrock, P. A. and Scargle, J. D. (2010). <em>False-alarm Probability in Relation to Oversampled Power Spectra, with Application to Super-Kamiokande Solar Neutrino Data</em>. <a href="https://doi.org/10.1088/0004-637X/718/1/527">The Astrophysical Journal <strong>718</strong>, 527–529</a>, <a href="https://arxiv.org/abs/1006.0546">arXiv:1006.0546 [hep-ph]</a>.</div></li></ul></div><p>The package provides facilities to:</p><ul><li>compute the periodogram using different methods (with different speeds) and different normalizations. This is one of the fastest implementations of these methods available as free software. If Julia is run with more than one <a href="http://docs.julialang.org/en/stable/manual/parallel-computing/#multi-threading-experimental">thread</a>, computation is automatically multi-threaded, further speeding up calculations;</li><li>access the frequency and period grid of the resulting periodogram, together with the power spectrum;</li><li>find the maximum power in the periodogram and the frequency and period corresponding to the peak. All these queries can be restricted to a specified region, in order to search a local maximum, instead of the global one;</li><li>calculate the probability that a peak arises from noise only (false-alarm probability) using analytic formulas, in order to assess the significance of the peak;</li><li>perform bootstrap resamplings in order to compute the false-alarm probability with a statistical method;</li><li>determine the best-fitting Lomb–Scargle model for the given data set at the given frequency.</li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#LombScargle.jl">LombScargle.jl</a></li><li class="no-marker"><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Contents">Contents</a></li><li><a href="#Installation">Installation</a></li><li><a href="#Usage">Usage</a></li><li class="no-marker"><ul><li><a href="#Planning-the-Periodogram">Planning the Periodogram</a></li><li><a href="#Fast-Algorithm">Fast Algorithm</a></li><li><a href="#Normalization">Normalization</a></li><li><a href="#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram">Access Frequency Grid and Power Spectrum of the Periodogram</a></li><li><a href="#Access-Period-Grid">Access Period Grid</a></li><li><a href="#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions"><code>findmaxpower</code>, <code>findmaxfreq</code>, and <code>findmaxperiod</code> Functions</a></li><li><a href="#False-Alarm-Probability">False-Alarm Probability</a></li><li class="no-marker"><ul><li><a href="#Bootstrapping">Bootstrapping</a></li></ul></li><li><a href="#LombScargle.model-Function"><code>LombScargle.model</code> Function</a></li></ul></li><li><a href="#Examples">Examples</a></li><li class="no-marker"><ul><li><a href="#Signal-with-Uncertainties">Signal with Uncertainties</a></li><li><a href="#Find-Highest-Power-and-Associated-Frequencies-and-Periods">Find Highest Power and Associated Frequencies and Periods</a></li><li><a href="#Significance-of-the-Peaks">Significance of the Peaks</a></li><li><a href="#Find-the-Best-Fitting-Model">Find the Best-Fitting Model</a></li></ul></li><li><a href="#Performance">Performance</a></li><li><a href="#Development">Development</a></li><li class="no-marker"><ul><li><a href="#History">History</a></li></ul></li><li><a href="#License">License</a></li><li class="no-marker"><ul><li><a href="#Acknowledgements">Acknowledgements</a></li></ul></li><li><a href="#References">References</a></li></ul></li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p><code>LombScargle.jl</code> is available for Julia 1.0 and later versions, and can be installed with Julia&#39;s built-in <a href="http://docs.julialang.org/en/stable/manual/packages/">package manager</a>. In a Julia session run the commands</p><pre><code class="language-julia-repl hljs">julia&gt; import Pkg
julia&gt; Pkg.add(&quot;LombScargle&quot;)</code></pre><p>Older versions are also available for Julia 0.4-0.6.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>After installing the package, you can start using it with</p><pre><code class="language-julia hljs">using LombScargle</code></pre><p>The module defines a new <code>LombScargle.Periodogram</code> data type, which, however, is not exported because you will most probably not need to directly manipulate such objects. This data type holds both the frequency and the power vectors of the periodogram.</p><p>The main function provided by the package is <code>lombscargle</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}" href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>LombScargle.lombscargle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lombscargle(times::AbstractVector{&lt;:Real}, signal::AbstractVector{&lt;:Real},
            [errors::AbstractVector{&lt;:Real}]; keywords...)</code></pre><p>Compute the Lomb–Scargle periodogram of the <code>signal</code> vector, observed at <code>times</code>.  You can also specify the uncertainties for each signal point with <code>errors</code> argument.  All these vectors must have the same length.</p><p>All optional keywords are described in the docstring of <a href="#LombScargle.plan"><code>LombScargle.plan</code></a>.</p><p>If the signal has uncertainties, the <code>signal</code> vector can also be a vector of <code>Measurement</code> objects (from <a href="https://github.com/giordano/Measurements.jl"><code>Measurements.jl</code></a> package), in which case you don’t need to pass a separate <code>errors</code> vector for the uncertainties of the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/LombScargle.jl#L80-L96">source</a></section></article><p><code>lombscargle</code> returns a <code>LombScargle.Periodogram</code>. The only two mandatory arguments are:</p><ul><li><code>times</code>: the vector of observation times</li><li><code>signal</code>: the vector of observations associated with <code>times</code></li></ul><p>The optional argument is:</p><ul><li><code>errors</code>: the uncertainties associated to each <code>signal</code> point.</li></ul><p>All these vectors must have the same length.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can pre-plan a periodogram with <a href="#LombScargle.plan"><code>LombScargle.plan</code></a> function, which has the same syntax as <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> described in this section. In this way the actual computation of the periodogram is faster and you will save memory. See the <a href="#Planning-the-Periodogram-1">Planning the Periodogram</a> section below.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>LombScargle.jl</code> exploits Julia&#39;s native <a href="http://docs.julialang.org/en/stable/manual/parallel-computing/#multi-threading-experimental">multi-threading</a> for the non-fast methods (the methods used when you set the keyword <code>fast=false</code>). Run Julia with <span>$n$</span> threads (e.g., <code>JULIA_NUM_THREADS=4 julia</code> for 4 threads, if your machine has 4 physical cores) in order to automatically gain an <span>$n$</span> -fold scaling.</p><p>Please note that multi-threading is still an experimental feature in Julia, so you may encounter issues when running it with more than one thread. For example, bug <a href="https://github.com/JuliaLang/julia/issues/17395">#17395</a> (if still open) may prevent the function, on some systems, from effectively scaling.</p></div></div><p>If the signal has uncertainties, the <code>signal</code> vector can also be a vector of <code>Measurement</code> objects (from <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a> package), in which case you need not to pass a separate <code>errors</code> vector for the uncertainties of the signal. You can create arrays of <code>Measurement</code> objects with the <code>measurement</code> function, see <code>Measurements.jl</code> manual at <a href="https://juliaphysics.github.io/Measurements.jl/stable">https://juliaphysics.github.io/Measurements.jl/stable</a> for more details. The generalised Lomb–Scargle periodogram by <a href="#ZK09">Zechmeister and Kürster (2009)</a> is always used when the signal has uncertainties, because the original Lomb–Scargle algorithm cannot handle them.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The uncertainties are only used in the generalised Lomb–Scargle algorithm to build an <a href="https://en.wikipedia.org/wiki/Inverse-variance_weighting">inverse-variance</a> weights vector (see <a href="#ZK09">Zechmeister and Kürster (2009)</a>), that gives more importance to datapoints with lower uncertainties. The case where all measurements have the same uncertainty (a condition known as <a href="https://en.wikipedia.org/wiki/Homoscedasticity">homoskedasticity</a>) results in a constant weights vector, like if there are no uncertainties at all. If you have homoskedastic errors, you do not need to provide them to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a>.</p></div></div><h3 id="Planning-the-Periodogram"><a class="docs-heading-anchor" href="#Planning-the-Periodogram">Planning the Periodogram</a><a id="Planning-the-Periodogram-1"></a><a class="docs-heading-anchor-permalink" href="#Planning-the-Periodogram" title="Permalink"></a></h3><p>In a manner similar to planning Fourier transforms with FFTW, it is possible to speed-up computation of the Lomb–Scargle periodogram by pre-planning it with <a href="#LombScargle.plan"><code>LombScargle.plan</code></a> function. It has the same syntax as <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a>, which in the base case is:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.plan" href="#LombScargle.plan"><code>LombScargle.plan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LombScargle.plan(times::AbstractVector{&lt;:Real}, signal::AbstractVector{&lt;:Real},
                 [errors::AbstractVector{&lt;:Real}];
                 normalization::Symbol=:standard,
                 noise_level::Real=1,
                 center_data::Bool=true,
                 fit_mean::Bool=true,
                 fast::Bool=true,
                 flags::Integer=FFTW.ESTIMATE,
                 timelimit::Real=Inf,
                 oversampling::Integer=5,
                 padding_factors::Vector{Int}=[2],
                 Mfft::Integer=4,
                 samples_per_peak::Integer=5,
                 nyquist_factor::Integer=5,
                 minimum_frequency::Real=NaN,
                 maximum_frequency::Real=NaN,
                 frequencies::AbstractVector{Real}=
                 autofrequency(times,
                               samples_per_peak=samples_per_peak,
                               nyquist_factor=nyquist_factor,
                               minimum_frequency=minimum_frequency,
                               maximum_frequency=maximum_frequency))</code></pre><p>Pre-plan the Lomb–Scargle periodogram of the <code>signal</code> vector, observed at <code>times</code>.  The periodogram can then be computed by passing the result of this function to <code>lombscargle</code>.</p><p>You can also specify the uncertainties for each signal point with <code>errors</code> argument.  All these vectors must have the same length.</p><p>Optional keywords arguments are:</p><ul><li><code>normalization</code>: how to normalize the periodogram.  Valid choices are: <code>:standard</code>, <code>:model</code>, <code>:log</code>, <code>:psd</code>, <code>:Scargle</code>, <code>:HorneBaliunas</code>, <code>:Cumming</code></li><li><code>noise_level</code>: the noise level used to normalize the periodogram when <code>normalization</code> is set to <code>:Scargle</code></li><li><code>fit_mean</code>: if <code>true</code>, fit for the mean of the signal using the Generalised Lomb–Scargle algorithm (see Zechmeister &amp; Kürster paper below).  If this is <code>false</code> and no uncertainty on the signal is provided, the original algorithm by Lomb and Scargle will be employed (see Townsend paper below)</li><li><code>center_data</code>: if <code>true</code>, subtract the weighted mean of <code>signal</code> from <code>signal</code> itself before performing the periodogram.  This is especially important if <code>fit_mean</code> is <code>false</code></li><li><code>frequencies</code>: the frequecy grid (not angular frequencies) at which the periodogram will be computed, as a vector.  If not provided, it is an evenly spaced grid of type <code>Range</code>, automatically determined with <code>LombScargle.autofrequency</code> function, which see.  See below for other available keywords that can be used to affect the frequency grid without directly setting <code>frequencies</code></li></ul><p>You can explicitely require to use or not the fast method by Press &amp; Rybicki, overriding the default choice, by setting the <code>fast</code> keyword.  In any case, <code>frequencies</code> must be a <code>Range</code> object (this is the default) in order to actually use this method.  A few other keywords are available to adjust the settings of the periodogram when the fast method is used (otherwise they are ignored):</p><ul><li><code>fast</code>: whether to use the fast method.</li><li><code>flags</code>: this integer keyword is a bitwise-or of FFTW planner flags, defaulting to <code>FFTW.ESTIMATE</code>.  Passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.</li><li><code>timelimit</code>: specifies a rough upper bound on the allowed planning time, in seconds.</li><li><code>oversampling</code>: oversampling the frequency factor for the approximation; roughly the number of time samples across the highest-frequency sinusoid. This parameter contains the tradeoff between accuracy and speed.</li><li><code>padding_factors</code>: the FFT is performed on a vector with length equal to the smallest number larger than or equal to <code>N * oversampling</code> which is a product of all numbers in this vector.  E.g., use <code>padding_factors=[2]</code> to perform the FFT on a vector padded to a power of 2, or <code>padding_factors=[2, 3, 5, 7]</code> for the optimal size for the FFTW library.</li><li><code>Mfft</code>: the number of adjacent points to use in the FFT approximation.</li></ul><p>In addition, you can use all optional keyword arguments of <a href="#LombScargle.autofrequency"><code>LombScargle.autofrequency</code></a> function in order to tune the <code>frequencies</code>.</p><p>If the signal has uncertainties, the <code>signal</code> vector can also be a vector of <code>Measurement</code> objects (from <a href="https://github.com/giordano/Measurements.jl"><code>Measurements.jl</code></a> package), in which case you don’t need to pass a separate <code>errors</code> vector for the uncertainties of the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/planning.jl#L147-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.autofrequency" href="#LombScargle.autofrequency"><code>LombScargle.autofrequency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">autofrequency(times::AbstractVector{Real};
              samples_per_peak::Integer=5,
              nyquist_factor::Integer=5,
              minimum_frequency::Real=NaN,
              maximum_frequency::Real=NaN)</code></pre><p>Determine a suitable frequency grid for the given vector of <code>times</code>.</p><p>Optional keyword arguments are:</p><ul><li><code>samples_per_peak</code>: the approximate number of desired samples across the typical peak</li><li><code>nyquist_factor</code>: the multiple of the average Nyquist frequency used to choose the maximum frequency if <code>maximum_frequency</code> is not provided</li><li><code>minimum_frequency</code>: if specified, then use this minimum frequency rather than one chosen based on the size of the baseline</li><li><code>maximum_frequency</code>: if specified, then use this maximum frequency rather than one chosen based on the average Nyquist frequency</li></ul><p>This is based on prescription given at <a href="https://jakevdp.github.io/blog/2015/06/13/lomb-scargle-in-python/">https://jakevdp.github.io/blog/2015/06/13/lomb-scargle-in-python/</a> and uses the same keywords names adopted in Astropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L110-L133">source</a></section></article><p><code>LombScargle.plan</code> takes all the same argument as <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> shown above and returns a <code>LombScargle.PeriodogramPlan</code> object after having pre-computed certain quantities needed afterwards, and pre-allocated the memory for the periodogram. It is highly suggested to plan a periodogram before actually computing it, especially for the fast method. Once you plan a periodogram, you can pass the <code>LombScargle.PeriodogramPlan</code> to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> as the only argument.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.lombscargle-Tuple{LombScargle.PeriodogramPlan}" href="#LombScargle.lombscargle-Tuple{LombScargle.PeriodogramPlan}"><code>LombScargle.lombscargle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lombscargle(plan::PeriodogramPlan)</code></pre><p>Compute the Lomb–Scargle periodogram for the given <code>plan</code>.  This method has no other arguments.  See documentation of <a href="#LombScargle.plan"><code>LombScargle.plan</code></a> for how to plan a Lomb–Scargle periodogram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/LombScargle.jl#L99-L105">source</a></section></article><p>Planning the periodogram has a twofold advantage. First of all, the planning stage is <a href="https://docs.julialang.org/en/latest/manual/performance-tips.html">type-unstable</a>, because the type of the plan depends on the value of input parameters, and not on their types. Thus, separating the planning (inherently inefficient) from the actual computation of the periodogram (completely type-stable) makes overall computation faster than directly calling <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a>. Secondly, the <code>LombScargle.PeriodogramPlan</code> bears the time vector, but the quantities that are pre-computed in planning stage do not actually depend on it. This is particularly useful if you want to calculate the <a href="#False-Alarm-Probability">False-Alarm Probability</a> via bootstrapping with <a href="#LombScargle.bootstrap"><code>LombScargle.bootstrap</code></a>: the vector time is randomly shuffled, but pre-computed quantities will remain the same, saving both time and memory in each iteration. In addition, you ensure that you will use the same options you used to compute the periodogram.</p><h3 id="Fast-Algorithm"><a class="docs-heading-anchor" href="#Fast-Algorithm">Fast Algorithm</a><a id="Fast-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Algorithm" title="Permalink"></a></h3><p>When the frequency grid is evenly spaced, you can compute an approximate generalised Lomb–Scargle periodogram using a fast algorithm proposed by <a href="#PR89">Press and Rybicki (1989)</a> that greatly speeds up calculations, as it scales as <span>$O[N \log(M)]$</span> for <span>$N$</span> data points and <span>$M$</span> frequencies. For comparison, the true Lomb–Scargle periodogram has complexity <span>$O[NM]$</span>.  The larger the number of datapoints, the more accurate the approximation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method internally performs a <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">Fast Fourier Transform</a> (FFT) to compute some quantities, but it is in no way equivalent to conventional Fourier periodogram analysis.</p><p><code>LombScargle.jl</code> uses <a href="http://fftw.org/">FFTW</a> functions to compute the FFT. You can speed-up this task by using multi-threading: call <code>FFTW.set_num_threads(n)</code> to use <span>$n$</span> threads. However, please note that the running time will not scale as <span>$n$</span> because computation of the FFT is only a part of the algorithm.</p></div></div><p>The only prerequisite in order to be able to employ this fast method is to provide a <code>frequencies</code> vector as an <code>AbstractRange</code> object, which ensures that the frequency grid is perfectly evenly spaced. This is the default, since <code>LombScargle.autofrequency</code> returns an <code>AbstractRange</code> object.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In Julia, an <code>AbstractRange</code> object can be constructed for example with the <a href="https://docs.julialang.org/en/latest/base/math/#Base.range"><code>range</code></a> function (you specify the start of the range, and optionally the stop, the length and the step of the vector) or with the syntax <a href="https://docs.julialang.org/en/latest/base/math/#Base.::"><code>start:[step:]stop</code></a> (you specify the start and the end of the range, and optionally the linear step).</p></div></div><p>Since this fast method is accurate only for large datasets, it is enabled by default only if the number of output frequencies is larger than 200. You can override the default choice of using this method by setting the <code>fast</code> keyword to <code>true</code> or <code>false</code>. We recall that in any case, the <code>frequencies</code> vector must be a <code>Range</code> in order to use this method.</p><p>To summarize, provided that <code>frequencies</code> vector is an <code>AbstractRange</code> object, you can use the fast method:</p><ul><li>by default if the length of the output frequency grid is larger than 200 points</li><li>in any case with the <code>fast=true</code> keyword</li></ul><p>Setting <code>fast=false</code> always ensures you that this method will not be used, instead <code>fast=true</code> actually enables it only if <code>frequencies</code> is an <code>AbstractRange</code>.</p><h3 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h3><p>By default, the periodogram <span>$p(f)$</span> is normalized so that it has values in the range <span>$0 \leq p(f) \leq 1$</span>, with <span>$p = 0$</span> indicating no improvement of the fit and <span>$p = 1$</span> a &quot;perfect&quot; fit (100% reduction of <span>$\chi^2$</span> or <span>$\chi^2 = 0$</span>). This is the normalization suggested by <a href="#LOM76">Lomb (1976)</a> and <a href="#ZK09">Zechmeister and Kürster (2009)</a>, and corresponds to the <code>:standard</code> normalization in <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> function. <a href="#ZK09">Zechmeister and Kürster (2009)</a> wrote the formula for the power of the periodogram at frequency <span>$f$</span> as</p><p class="math-container">\[p(f) = \frac{1}{YY} \left[
\frac{YC^2_{\tau}}{CC_{\tau}} +
\frac{YS^2_{\tau}}{SS_{\tau}}
\right]\]</p><p>See the paper for details. The other normalizations for periodograms <span>$P(f)$</span> are calculated from this one. In what follows, <span>$N$</span> is the number of observations.</p><ul><li><p><code>:model</code>:</p><p class="math-container">\[P(f) = \frac{p(f)}{1 - p(f)}\]</p></li><li><p><code>:log</code>:</p><p class="math-container">\[P(f) = -\log(1 - p(f))\]</p></li><li><p><code>:psd</code>:</p><p class="math-container">\[P(f) = \frac{W}{2}\left[\frac{YC^2_{\tau}}{CC_{\tau}} +
\frac{YS^2_{\tau}}{SS_{\tau}}\right] = p(f) \frac{W*YY}{2}\]</p><p>where W is the sum of the inverse of the individual errors, <span>$W = \sum \frac{1}{\sigma_{i}}$</span>, as given in <a href="#ZK09">Zechmeister and Kürster (2009)</a>.</p></li><li><p><code>:Scargle</code>:</p><p class="math-container">\[P(f) = \frac{p(f)}{\text{noise level}}\]</p><p>This normalization can be used when you know the noise level (expected from the a priori known noise variance or population variance), but this isn&#39;t usually the case. See <a href="#SCA82">Scargle (1982)</a></p></li><li><p><code>:HorneBaliunas</code>:</p><p class="math-container">\[P(f) = \frac{N - 1}{2} p(f)\]</p><p>This is like the <code>:Scargle</code> normalization, where the noise has been estimated for Gaussian noise to be <span>$(N - 1)/2$</span>. See <a href="#HB86">Horne and Baliunas (1986)</a></p></li><li><p>If the data contains a signal or if errors are under- or overestimated or if intrinsic variability is present, then <span>$(N-1)/2$</span> may not be a good uncorrelated estimator for the noise level.  <a href="#CMB99">Cumming <em>et al.</em> (1999)</a> suggested to estimate the noise level a posteriori with the residuals of the best fit and normalised the periodogram as:</p><p class="math-container">\[P(f) = \frac{N - 3}{2} \frac{p(f)}{1 - p(f_{\text{best}})}\]</p><p>This is the <code>:Cumming</code> normalization option</p></li></ul><h3 id="Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram"><a class="docs-heading-anchor" href="#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram">Access Frequency Grid and Power Spectrum of the Periodogram</a><a id="Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram-1"></a><a class="docs-heading-anchor-permalink" href="#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram" title="Permalink"></a></h3><p><a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> returns a <code>LombScargle.Periodogram</code> object, but you most probably want to use the frequency grid and the power spectrum. You can access these vectors with <code>freq</code> and <code>power</code> functions, just like in <code>DSP.jl</code> package. If you want to get the 2-tuple <code>(freq(p), power(p))</code> use the <code>freqpower</code> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.power" href="#LombScargle.power"><code>LombScargle.power</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">power(p::Periodogram)</code></pre><p>Return the power vector of Lomb–Scargle periodogram <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.freq" href="#LombScargle.freq"><code>LombScargle.freq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freq(p::Periodogram)</code></pre><p>Return the frequency vector of Lomb–Scargle periodogram <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.freqpower" href="#LombScargle.freqpower"><code>LombScargle.freqpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freqpower(p::Periodogram)</code></pre><p>Return the 2-tuple <code>(freq(p), power(p))</code>, where <code>freq(p)</code> and <code>power(p)</code> are the frequency vector and the power vector of Lomb–Scargle periodogram <code>p</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L35-L41">source</a></section></article><h3 id="Access-Period-Grid"><a class="docs-heading-anchor" href="#Access-Period-Grid">Access Period Grid</a><a id="Access-Period-Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Access-Period-Grid" title="Permalink"></a></h3><p>The following utilities are the analogs of <a href="#LombScargle.freq"><code>freq</code></a> and <a href="#LombScargle.freqpower"><code>freqpower</code></a>, but relative to the periods instead of the frequencies. Thus <code>period(p)</code> returns the vector of periods in the periodogram, that is <code>1./freq(p)</code>, and <code>periodpower(p)</code> gives you the 2-tuple <code>(period(p), power(p))</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.period" href="#LombScargle.period"><code>LombScargle.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">period(p::Periodogram)</code></pre><p>Return the period vector of Lomb–Scargle periodogram <code>p</code>.  It is equal to <code>1 ./ freq(p)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.periodpower" href="#LombScargle.periodpower"><code>LombScargle.periodpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">periodpower(p::Periodogram)</code></pre><p>Return the 2-tuple <code>(period(p), power(p))</code>, where <code>period(p)</code> and <code>power(p)</code> are the period vector and the power vector of Lomb–Scargle periodogram <code>p</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L85-L91">source</a></section></article><h3 id="findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions"><a class="docs-heading-anchor" href="#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions"><code>findmaxpower</code>, <code>findmaxfreq</code>, and <code>findmaxperiod</code> Functions</a><a id="findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions" title="Permalink"></a></h3><p>Once you compute the periodogram, you usually want to know which are the frequencies or periods with highest power. To do this, you can use the <a href="#LombScargle.findmaxfreq"><code>findmaxfreq</code></a> and <a href="#LombScargle.findmaxperiod"><code>findmaxperiod</code></a> functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.findmaxpower" href="#LombScargle.findmaxpower"><code>LombScargle.findmaxpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findmaxpower(p::Periodogram)</code></pre><p>Return the highest power of the periodogram <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.findmaxfreq" href="#LombScargle.findmaxfreq"><code>LombScargle.findmaxfreq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findmaxfreq(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p))</code></pre><p>Return the array of frequencies with the highest power in the periodogram <code>p</code>. If a scalar real argument <code>threshold</code> is provided, return the frequencies with power larger than or equal to <code>threshold</code>.  If you want to limit the search to a narrower frequency range, pass as second argument a vector with the extrema of the interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.findmaxperiod" href="#LombScargle.findmaxperiod"><code>LombScargle.findmaxperiod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findmaxperiod(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p))</code></pre><p>Return the array of periods with the highest power in the periodogram <code>p</code>.  If a scalar real argument <code>threshold</code> is provided, return the period with power larger than or equal to <code>threshold</code>.  If you want to limit the search to a narrower period range, pass as second argument a vector with the extrema of the interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L95-L103">source</a></section></article><h3 id="False-Alarm-Probability"><a class="docs-heading-anchor" href="#False-Alarm-Probability">False-Alarm Probability</a><a id="False-Alarm-Probability-1"></a><a class="docs-heading-anchor-permalink" href="#False-Alarm-Probability" title="Permalink"></a></h3><p>Noise in the data produce fluctuations in the periodogram that will present several local peaks, but not all of them related to real periodicities. The significance of the peaks can be tested by calculating the probability that its power can arise purely from noise.  The higher the value of the power, the lower will be this probability.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="#CMB99">Cumming <em>et al.</em> (1999)</a> showed that the different normalizations result in different probability functions. <code>LombScargle.jl</code> can calculate the probability (and the false-alarm probability) only for the normalizations reported by <a href="#ZK09">Zechmeister and Kürster (2009)</a>, that are <code>:standard</code>, <code>:Scargle</code>, <code>:HorneBaliunas</code>, and <code>:Cumming</code>.</p></div></div><p>The probability <span>$\Pr(p &gt; p_0)$</span> that the periodogram power <span>$p$</span> can exceed the value <span>$p_0$</span> can be calculated with the <a href="#LombScargle.prob-Tuple{LombScargle.Periodogram, Real}"><code>prob</code></a> function, whose first argument is the periodogram and the second one is the <span>$p_0$</span> value. The function <a href="#LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}"><code>probinv</code></a> is its inverse: it takes the probability as second argument and returns the corresponding <span>$p_0$</span> value.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.prob-Tuple{LombScargle.Periodogram, Real}" href="#LombScargle.prob-Tuple{LombScargle.Periodogram, Real}"><code>LombScargle.prob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prob(P::Periodogram, pow::Real)</code></pre><p>Return the probability that the periodogram power can exceed the value <code>pow</code>.</p><p>Its inverse is the <code>probinv</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}" href="#LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}"><code>LombScargle.probinv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probinv(P::Periodogram, prob::Real)</code></pre><p>Return the power value of the periodogram power whose probability is <code>prob</code>.</p><p>This is the inverse of <code>prob</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L172-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.M" href="#LombScargle.M"><code>LombScargle.M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LombScargle.M(P::Periodogram)</code></pre><p>Estimates the number of independent frequencies in the periodogram <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.fap-Tuple{LombScargle.Periodogram, Real}" href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>LombScargle.fap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fap(P::Periodogram, pow::Real)</code></pre><p>Return the false-alarm probability for periodogram <code>P</code> and power value <code>pow</code>.</p><p>Its inverse is the <a href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>fapinv</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}" href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>LombScargle.fapinv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fapinv(P::Periodogram, prob::Real)</code></pre><p>Return the power value of the periodogram whose false-alarm probability is <code>prob</code>.</p><p>This is the inverse of <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L215-L222">source</a></section></article><p>Here are the probability functions for each normalization supported by <code>LombScargle.jl</code>:</p><ul><li><p><code>:standard</code> (<span>$p \in [0, 1]$</span>):</p><p class="math-container">\[\Pr(p &gt; p_0) = (1 - p_0)^{(N - 3)/2}\]</p></li><li><p><code>:Scargle</code> (<span>$p \in [0, \infty)$</span>):</p><p class="math-container">\[\Pr(p &gt; p_0) = \exp(-p_0)\]</p></li><li><p><code>:HorneBaliunas</code> (<span>$p \in [0, (N - 1)/2]$</span>):</p><p class="math-container">\[\Pr(p &gt; p_0) = \left(1 - \frac{2p_0}{N - 1}\right)^{(N - 3)/2}\]</p></li><li><p><code>:Cumming</code> (<span>$p \in [0, \infty)$</span>):</p><p class="math-container">\[\Pr(p &gt; p_0) = \left(1 + \frac{2p_0}{N - 3}\right)^{-(N - 3)/2}\]</p></li></ul><p>As explained by <a href="#SS10">Sturrock and Scargle (2010)</a>, «the term &quot;false-alarm probability denotes the probability that at least one out of <span>$M$</span> independent power values in a prescribed search band of a power spectrum computed from a white-noise time series is expected to be as large as or larger than a given value». <code>LombScargle.jl</code> provides the <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a> function to calculate the false-alarm probability (FAP) of a given power in a periodogram. Its first argument is the periodogram, the second one is the value <span>$p_0$</span> of the power of which you want to calculate the FAP. The function <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a> uses the formula</p><p class="math-container">\[\mathrm{FAP} = 1 - (1 - \Pr(p &gt; p_0))^M\]</p><p>where <span>$M$</span> is the number of independent frequencies estimated with <span>$M = T \cdot \Delta f$</span>, being <span>$T$</span> the duration of the observations and <span>$\Delta f$</span> the width of the frequency range in which the periodogram has been calculated (see <a href="#CUM04">Cumming (2004)</a>). The function <a href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>fapinv</code></a> is the inverse of <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a>: it takes as second argument the value of the FAP and returns the corresponding value <span>$p_0$</span> of the power.</p><p>The detection threshold <span>$p_0$</span> is the periodogram power corresponding to some (small) value of <span>$\mathrm{FAP}$</span>, i.e. the value of <span>$p$</span> exceeded due to noise alone in only a small fraction <span>$\mathrm{FAP}$</span> of trials. An observed power larger than <span>$p_0$</span> indicates that a signal is likely present (see <a href="#CUM04">Cumming (2004)</a>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Some authors stressed that this method to calculate the false-alarm probability is not completely reliable. A different approach to calculate the false-alarm probability is to perform Monte Carlo or bootstrap simulations in order to determine how often a certain power level <span>$p_0$</span> is exceeded just by chance (see <a href="#CMB99">Cumming <em>et al.</em> (1999)</a>, <a href="#CUM04">Cumming (2004)</a>, and <a href="#ZK09">Zechmeister and Kürster (2009)</a>). See the <a href="#Bootstrapping">Bootstrapping</a> section.</p></div></div><h4 id="Bootstrapping"><a class="docs-heading-anchor" href="#Bootstrapping">Bootstrapping</a><a id="Bootstrapping-1"></a><a class="docs-heading-anchor-permalink" href="#Bootstrapping" title="Permalink"></a></h4><p>One of the possible and simplest statistical methods that you can use to measure the false-alarm probability and its inverse is <a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29">bootstrapping</a> (see section 4.2.2 of <a href="#MHC93">Murdoch <em>et al.</em> (1993)</a>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We emphasize that you can use this method only if you know your data points are <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">independent and identically distributed</a>, and they have <a href="https://en.wikipedia.org/wiki/White_noise">white uncorrelated noise</a>.</p></div></div><p>The recipe of the bootstrap method is very simple to implement:</p><ul><li>repeat the Lomb–Scargle analysis a large number <span>$N$</span> of times on the original data, but with the signal (and errors, if present) vector randomly shuffled. As an alternative, shuffle only the time vector;</li><li>out of all these simulations, store the powers of the highest peaks;</li><li>in order to estimate the false-alarm probability of a given power, count how many times the highest peak of the simulations exceeds that power, as a fraction of <span>$N$</span>. If you instead want to find the inverse of the false-alarm probability <span>$\text{prob}$</span>, looks for the <span>$N\cdot\text{prob}$</span>-th element of the highest peaks vector sorted in descending order.</li></ul><p>Remember to pass to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> function the same options, if any, you used to compute the Lomb–Scargle periodogram before.</p><p><code>LombScargle.jl</code> provides simple methods to perform such analysis. The <a href="#LombScargle.bootstrap"><code>LombScargle.bootstrap</code></a> function allows you to create a bootstrap sample with <code>N</code> permutations of the original data.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.bootstrap" href="#LombScargle.bootstrap"><code>LombScargle.bootstrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LombScargle.bootstrap(N::Integer,
                      times::AbstractVector{Real},
                      signal::AbstractVector{Real},
                      errors::AbstractVector{Real}=ones(signal); ...)</code></pre><p>Create <code>N</code> bootstrap samples, perform the Lomb–Scargle analysis on them, and store all the highest peaks for each one in a <code>LombScargle.Bootstrap</code> object. All the arguments after <code>N</code> are passed around to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/bootstrap.jl#L45-L54">source</a></section><section><div><pre><code class="language-julia hljs">LombScargle.bootstrap(N::Integer, plan::PeriodogramPlan)</code></pre><p>Create <code>N</code> bootstrap samples, perform the Lomb–Scargle analysis on them for the given <code>plan</code>, and store all the highest peaks for each one in a <code>LombScargle.Bootstrap</code> object.</p><p>See documentation of <a href="#LombScargle.plan"><code>LombScargle.plan</code></a> for how to plan a Lomb–Scargle periodogram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/bootstrap.jl#L57-L64">source</a></section></article><p>The false-alarm probability and its inverse can be calculated with <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a> and <a href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>fapinv</code></a> functions respectively.  Their syntax is the same as the methods introduced above, but with a <code>LombScargle.Bootstrap</code> object as first argument, instead of the <code>LombScargle.Periodogram</code> one.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.fap-Tuple{LombScargle.Bootstrap, Real}" href="#LombScargle.fap-Tuple{LombScargle.Bootstrap, Real}"><code>LombScargle.fap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fap(b::Bootstrap, power::Real)</code></pre><p>Return the false-alarm probability for <code>power</code> in the bootstrap sample <code>b</code>.</p><p>Its inverse is the <a href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>fapinv</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/bootstrap.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.fapinv-Tuple{LombScargle.Bootstrap, Real}" href="#LombScargle.fapinv-Tuple{LombScargle.Bootstrap, Real}"><code>LombScargle.fapinv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fapinv(b::Bootstrap, prob::Real)</code></pre><p>Return the power value whose false-alarm probability is <code>prob</code> in the bootstrap sample <code>b</code>.</p><p>It returns <code>NaN</code> if the requested probability is too low and the power cannot be determined with the bootstrap sample <code>b</code>.  In this case, you should enlarge your bootstrap sample so that <code>N*fap</code> can be rounded to an integer larger than or equal to 1.</p><p>This is the inverse of <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/bootstrap.jl#L77-L89">source</a></section></article><h3 id="LombScargle.model-Function"><a class="docs-heading-anchor" href="#LombScargle.model-Function"><code>LombScargle.model</code> Function</a><a id="LombScargle.model-Function-1"></a><a class="docs-heading-anchor-permalink" href="#LombScargle.model-Function" title="Permalink"></a></h3><p>For each frequency <span>$f$</span> (and hence for the corresponding angular frequency <span>$\omega = 2\pi f$</span>) the Lomb–Scargle algorithm looks for the sinusoidal function of the type</p><p class="math-container">\[a_f\cos(\omega t) + b_f\sin(\omega t) + c_f\]</p><p>that best fits the data. In the original Lomb–Scargle algorithm the offset <span>$c$</span> is null (see <a href="#LOM76">Lomb (1976)</a>). In order to find the best-fitting coefficients <span>$a_f$</span>, <span>$b_f$</span>, and <span>$c_f$</span> for the given frequency <span>$f$</span>, without actually performing the periodogram, you can solve the linear system <span>$\mathbf{A} \mathbf{x} = \mathbf{y}$</span>, where <span>$\mathbf{A}$</span> is the matrix</p><p class="math-container">\[\begin{bmatrix}
  \cos(\omega t) &amp; \sin(\omega t) &amp; 1
\end{bmatrix} =
\begin{bmatrix}
  \cos(\omega t_1) &amp; \sin(\omega t_1) &amp; 1      \\
  \vdots           &amp; \vdots           &amp; \vdots \\
  \cos(\omega t_n) &amp; \sin(\omega t_n) &amp; 1
\end{bmatrix}\]</p><p><span>$t = [t_1, \dots, t_n]^\mathsf{T}$</span> is the column vector of observation times, <span>$\mathbf{x}$</span> is the column vector with the unknown coefficients</p><p class="math-container">\[\begin{bmatrix}
    a_f \\
    b_f \\
    c_f
\end{bmatrix}\]</p><p>and <span>$\mathbf{y}$</span> is the column vector of the signal. The solution of the matrix gives the wanted coefficients.</p><p>This is what the <a href="#LombScargle.model"><code>LombScargle.model</code></a> function does in order to return the best fitting Lomb–Scargle model for the given signal at the given frequency.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LombScargle.model" href="#LombScargle.model"><code>LombScargle.model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LombScargle.model(times::AbstractVector{Real},
                  signal::AbstractVector{R2},
                  [errors::AbstractVector{R3},]
                  frequency::Real,
                  [times_fit::AbstractVector{R4}];
                  center_data::Bool=true,
                  fit_mean::Bool=true)</code></pre><p>Return the best fitting Lomb–Scargle model for the given signal at the given frequency.</p><p>Mandatory arguments are:</p><ul><li><code>times</code>: the observation times</li><li><code>signal</code>: the signal, sampled at <code>times</code> (must have the same length as <code>times</code>)</li><li><code>frequency</code>: the frequency at which to calculate the model</li></ul><p>Optional arguments are:</p><ul><li><p><code>errors</code>: the vector of uncertainties of the signal.  If provided, it must have the same length as <code>signal</code> and <code>times</code>, and be the third argument.  Like for <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a>, if the signal has uncertainties, the <code>signal</code> vector can also be a vector of <code>Measurement</code> objects, and this argument should be omitted</p></li><li><p><code>times_fit</code>: the vector of times at which the model will be calculated.  It defaults to <code>times</code>.  If provided, it must come after <code>frequency</code></p></li></ul><p>Optional keyword arguments <code>center_data</code> and <code>fit_mean</code> have the same meaning as in <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a>:</p><ul><li><code>fit_mean</code>: whether to fit for the mean. If this is <code>false</code>, like in the original Lomb–Scargle periodogram, <span>$\mathbf{A}$</span> does not have the third column of ones, <span>$c_f$</span> is set to <span>$0$</span> and the unknown vector to be determined becomes <span>$x = [a_f, b_f]^\text{T}$</span></li><li><code>center_data</code>: whether the data should be pre-centered before solving the linear system. This is particularly important if <code>fit_mean=false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/LombScargle.jl/blob/90c4fbc34127aac0cd078940bc8b38c2ee01b990/src/utils.jl#L225-L264">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Here is an example of a noisy periodic signal (<span>$\sin(\pi t) + 1.5\cos(2\pi t)$</span>) sampled at unevenly spaced times.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LombScargle</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(42); # make plots reproducible</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ntimes = 1001;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = range(0.01, 10pi, length = ntimes) # Observation times</code><code class="nohighlight hljs ansi" style="display:block;">0.01:0.03140592653589793:31.41592653589793</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t += step(t)*rand(ntimes); # Randomize times</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = sinpi.(t) .+ 1.5cospi.(2t) .+ rand(ntimes); # The signal</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plan = LombScargle.plan(t, s); # Pre-plan the periodogram</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pgram = lombscargle(plan) # Compute the periodogram</code><code class="nohighlight hljs ansi" style="display:block;">LombScargle.Periodogram{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Vector{Float64}}([0.0009002061856020596, 0.0008836113626863781, 0.0008495252318279351, 0.0007945083538758122, 0.0007052919678129175, 0.0005425637744200134, 0.0002821925162241195, 5.119517579364273e-5, 3.589360431210285e-5, 0.00019032755028405127  …  0.0011197360659888319, 0.0013600579636300514, 0.0009567336181250871, 0.00022198735604679484, 7.888602659701585e-5, 0.0010836848233666905, 0.0026394015757926293, 0.0034258931687385576, 0.0027428417988911587, 0.0011372880435844058], 0.0031823671601760094:0.006364734320352019:79.63237344908428, [0.015451270375901948, 0.051508007716585986, 0.08093296934439527, 0.10944493943658266, 0.15217510074016963, 0.18219939042833327, 0.21070470491330284, 0.25505298746255434, 0.2920490151715063, 0.2956190459595937  …  31.143038468604786, 31.164857936510924, 31.20507145945872, 31.233375392399598, 31.271122085204944, 31.314799568543375, 31.344062482974675, 31.380022287634237, 31.38983942755385, 31.438601072634807], :standard)</code></pre><p>You can plot the result, for example with <a href="https://github.com/tbreloff/Plots.jl">Plots</a> package. Use <a href="#LombScargle.freqpower"><code>freqpower</code></a> function to get the frequency grid and the power of the periodogram as a 2-tuple.</p><pre><code class="language-julia hljs">using Plots
plot(freqpower(pgram)...)</code></pre><img src="index-5704143a.svg" alt="Example block output"/><p>You can also plot the power vs the period, instead of the frequency, with <a href="#LombScargle.periodpower"><code>periodpower</code></a>:</p><pre><code class="language-julia hljs">using Plots
plot(periodpower(pgram)...)
xlabel!(&quot;Period&quot;)
ylabel!(&quot;Lomb–Scargle power&quot;)</code></pre><img src="index-ec160ce9.svg" alt="Example block output"/><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you do not fit for the mean of the signal (<code>fit_mean=false</code> keyword to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> function) without centering the data (<code>center_data=false</code>) you can get inaccurate results. For example, spurious peaks at low frequencies can appear and the real peaks lose power:</p><pre><code class="language-julia hljs">plot(freqpower(lombscargle(t, s, fit_mean=false, center_data=false))...)</code></pre><img src="index-6dbddb6b.svg" alt="Example block output"/></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can tune the frequency grid with appropriate keywords to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> function. For example, in order to increase the sampling increase <code>samples_per_peak</code>, and set <code>maximum_frequency</code> to lower values in order to narrow the frequency range:</p><pre><code class="language-julia hljs">plot(freqpower(lombscargle(t, s, samples_per_peak=20, maximum_frequency=1.5))...)</code></pre><img src="index-c745d3f5.svg" alt="Example block output"/><p>If you simply want to use your own frequency grid, directly set the <code>frequencies</code> keyword:</p><pre><code class="language-julia hljs">plot(freqpower(lombscargle(t, s, frequencies=0.001:1e-3:1.5))...)</code></pre><img src="index-42a30f36.svg" alt="Example block output"/></div></div><h3 id="Signal-with-Uncertainties"><a class="docs-heading-anchor" href="#Signal-with-Uncertainties">Signal with Uncertainties</a><a id="Signal-with-Uncertainties-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-with-Uncertainties" title="Permalink"></a></h3><p>The generalised Lomb–Scargle periodogram is able to handle a signal with uncertainties, and they will be used as weights in the algorithm.  The uncertainties can be passed either as the third optional argument <code>errors</code> to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> or by providing this function with a <code>signal</code> vector of type <code>Measurement</code> (from <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a> package).</p><pre><code class="language-julia hljs">using Measurements, Plots
ntimes = 1001
t = range(0.01, stop = 10pi, length = ntimes)
s = sinpi.(2t)
errors = rand(0.1:1e-3:4.0, ntimes)
# Run one of the two following equivalent commands
plot(freqpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)
plot(freqpower(lombscargle(t, measurement.(s, errors), maximum_frequency=1.5))...)</code></pre><img src="index-8abf5bc3.svg" alt="Example block output"/><p>This is the plot of the power versus the period:</p><pre><code class="language-julia hljs"># Run one of the two following equivalent commands
plot(periodpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)
plot(periodpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...)</code></pre><img src="index-91e32ee2.svg" alt="Example block output"/><p>We recall that the generalised Lomb–Scargle algorithm is used when the <code>fit_mean</code> optional keyword to <a href="#LombScargle.lombscargle-Tuple{AbstractVector{&lt;:Real}, Vararg{Any}}"><code>lombscargle</code></a> is <code>true</code> if no error is provided, instead it is always used if the signal has uncertainties.</p><h3 id="Find-Highest-Power-and-Associated-Frequencies-and-Periods"><a class="docs-heading-anchor" href="#Find-Highest-Power-and-Associated-Frequencies-and-Periods">Find Highest Power and Associated Frequencies and Periods</a><a id="Find-Highest-Power-and-Associated-Frequencies-and-Periods-1"></a><a class="docs-heading-anchor-permalink" href="#Find-Highest-Power-and-Associated-Frequencies-and-Periods" title="Permalink"></a></h3><p><a href="#LombScargle.findmaxfreq"><code>findmaxfreq</code></a> function tells you the frequencies with the highest power in the periodogram (and you can get the period by taking its inverse):</p><pre><code class="language-julia-repl hljs">julia&gt; t = range(0, stop = 10, length = 1001);

julia&gt; s = sinpi.(t);

julia&gt; plan = LombScargle.plan(t, s); # Plan the periodogram

julia&gt; p = lombscargle(plan);

julia&gt; findmaxperiod(p) # Period with highest power
1-element Vector{Float64}:
 0.004987779939149084

julia&gt; findmaxfreq(p) # Frequency with the highest power
1-element Vector{Float64}:
 200.49</code></pre><p>This peak is at high frequencies, very far from the expected value of the period of 2. In order to find the real peak, you can either narrow the ranges in order to exclude higher armonics</p><pre><code class="language-julia-repl hljs">julia&gt; findmaxperiod(p, [1, 10]) # Limit the search to periods in [1, 10]
1-element Vector{Float64}:
 2.0408163265306123

julia&gt; findmaxfreq(p, [0.1, 1]) # Limit the search to frequencies in [0.1, 1]
1-element Vector{Float64}:
 0.49</code></pre><p>or pass the <code>threshold</code> argument to <a href="#LombScargle.findmaxfreq"><code>findmaxfreq</code></a> or <a href="#LombScargle.findmaxperiod"><code>findmaxperiod</code></a>. You can use <a href="#LombScargle.findmaxpower"><code>findmaxpower</code></a> to discover the highest power in the periodogram:</p><pre><code class="language-julia-repl hljs">julia&gt; findmaxpower(p)
0.9996235276303144

julia&gt; findmaxperiod(p, 0.95)
10-element Vector{Float64}:
 2.0408163265306123
 1.9607843137254901
 0.010051261433309882
 0.010049241282283187
 0.009951238929246691
 0.009949258780220873
 0.005012782595618828
 0.005012280086211218
 0.004987779939149084
 0.004987282429804

julia&gt; findmaxfreq(p, 0.95)
10-element Vector{Float64}:
   0.49
   0.51
  99.49
  99.51
 100.49
 100.51
 199.49
 199.51
 200.49
 200.51</code></pre><p>The first peak is the real one, the other double peaks appear at higher armonics.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Usually, plotting the periodogram can give you a clearer idea of what&#39;s going on.</p></div></div><h3 id="Significance-of-the-Peaks"><a class="docs-heading-anchor" href="#Significance-of-the-Peaks">Significance of the Peaks</a><a id="Significance-of-the-Peaks-1"></a><a class="docs-heading-anchor-permalink" href="#Significance-of-the-Peaks" title="Permalink"></a></h3><p>The significance of the peaks in the Lomb–Scargle periodogram can be assessed by measuring the <a href="#false-alarm-probability">False-Alarm Probability</a>. Analytic expressions of this quantity and its inverse can be obtained with the <a href="#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}"><code>fap</code></a> and <a href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>fapinv</code></a> functions, respectively.</p><pre><code class="language-julia-repl hljs">julia&gt; t = linspace(0.01, 20, samples_per_peak = 10);

julia&gt; s = sinpi.(e.*t).^2 .- cos.(5t).^4;

julia&gt; plan = LombScargle.plan(t, s);

julia&gt; p = lombscargle(plan);

# Find the false-alarm probability for the highest peak.
julia&gt; fap(p, 0.3)
0.028198095962262748</code></pre><p>Thus, a peak with power <span>$0.3$</span> has a probability of <span>$0.028$</span> that it is due to noise only. A quantity that is often used is the inverse of the false-alarm probability as well: what is the minimum power whose false-alarm probability is lower than the given probability? For example, if you want to know the minimum power for which the false-alarm probability is at most <span>$0.01$</span> you can use:</p><pre><code class="language-julia-repl hljs">julia&gt; fapinv(p, 0.01)
0.3304696923786712</code></pre><p>As we already noted, analytic expressions of the false-alarm probability and its inverse may not be reliable if your data does not satisfy specific assumptions. A better way to calculate this quantity is to use statistical methods. One of this is bootstrapping. In <code>LombScargle.jl</code>, you can use the function <a href="#LombScargle.bootstrap"><code>LombScargle.bootstrap</code></a> to create a bootstrap sample and then you can calculate the false-alarm probability and its inverse using this sample.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>When applying the bootstrap method you should use the same options you used to perform the periodogram on your data. Using the same periodogram plan you used to compute the periodogram will ensure that you use the same options. However, note that the fast method gives approximate results that for some frequencies may not be reliable (they can go outside the range <span>$[0, 1]$</span> for the standard normalization). More robust results can be obtained with the <code>fast = false</code> option.</p></div></div><p>Create a bootstrap sample with 10000 resamplings of the original data, re-using the same periodogram plan.  The larger the better. This may take some minutes.</p><pre><code class="language-julia-repl hljs">julia&gt; b = LombScargle.bootstrap(10000, plan)</code></pre><p>Calculate the false-alarm probability of a peak with power 0.3 using this bootstrap sample.</p><pre><code class="language-julia-repl hljs">julia&gt; fap(b, 0.3)
0.0209</code></pre><p>Calculate the lowest power that has probability less than 0.01 in this bootstrap sample.</p><pre><code class="language-julia-repl hljs">julia&gt; fapinv(b, 0.01)
0.3268290388848437</code></pre><p>If you query <a href="#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}"><code>fapinv</code></a> with a too low probability, the corresponding power cannot be determined and you will get <code>NaN</code> as result.</p><pre><code class="language-julia-repl hljs">julia&gt; fapinv(b, 1e-5)
NaN</code></pre><p>If you want to find the power corresponding to a false-alarm probability of <span>$\text{prob} = 10^{-5}$</span>, you have to create a new bootstrap sample with <span>$N$</span> resamplings so that <span>$N\cdot\text{prob}$</span> can be rounded to an integer larger than or equal to one (for example <span>$N = 10^{5}$</span>).</p><h3 id="Find-the-Best-Fitting-Model"><a class="docs-heading-anchor" href="#Find-the-Best-Fitting-Model">Find the Best-Fitting Model</a><a id="Find-the-Best-Fitting-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Find-the-Best-Fitting-Model" title="Permalink"></a></h3><p>The <a href="#LombScargle.model"><code>LombScargle.model</code></a> function can help you to test whether a certain frequency fits well your data.</p><pre><code class="language-julia hljs">using LombScargle
using Random
using Plots
Random.seed!(42)
t = range(0.01, stop = 10pi, length = 1000) # Observation times
s = sinpi.(t) .+ 1.2cospi.(t) .+ 0.3rand(length(t)) # The noisy signal
# Pick-up the best frequency
f = findmaxfreq(lombscargle(t, s, maximum_frequency=10, samples_per_peak=20))[1]
t_fit = range(0, stop = 1, length = 50)
s_fit = LombScargle.model(t, s, f, t_fit/f) # Determine the model
scatter(mod.(t.*f, 1), s, lab=&quot;Phased data&quot;, title=&quot;Best Lomb-Scargle frequency: $f&quot;)
plot!(t_fit, s_fit, lab=&quot;Best-fitting model&quot;, linewidth=4)</code></pre><img src="index-a86505cf.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If there are more than one dominant frequency you may need to consider more models. This task may require some work and patience. Plot the periodogram in order to find the best frequencies.</p><pre><code class="language-julia hljs">using LombScargle
using Random
using Plots
Random.seed!(42)
t = range(0.01, stop = 5, length = 1000) # Observation times
s = sinpi.(2t) .+ 1.2cospi.(4t) .+ 0.3rand(length(t)) # Noisy signal
plan = LombScargle.plan(t, s, samples_per_peak=50)
p = lombscargle(plan)
# After plotting the periodogram, you discover
# that it has two prominent peaks around 1 and 2.
f1 = findmaxfreq(p, [0.8, 1.2])[1] # Get peak frequency around 1
f2 = findmaxfreq(p, [1.8, 2.2])[1] # Get peak frequency around 2
fit1 = LombScargle.model(t, s, f1) # Determine the first model
fit2 = LombScargle.model(t, s, f2) # Determine the second model
scatter(t, s, lab=&quot;Data&quot;, title=&quot;Best-fitting Lomb-Scargle model&quot;)
plot!(t, fit1 + fit2, lab=&quot;Best-fitting model&quot;, linewidth=4)</code></pre><img src="index-236868ed.svg" alt="Example block output"/></div></div><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p>A pre-planned periodogram in <code>LombScargle.jl</code> computed in single thread mode with the fast method is more than 2 times faster than the implementation of the same algorithm provided by AstroPy, and more than 4 times faster if 4 FFTW threads are used (on machines with at least 4 physical CPUs).</p><p>The following plot shows a comparison between the times needed to compute a periodogram for a signal with N datapoints using <code>LombScargle.jl</code>, with 1 or 4 FFTW threads (with <code>flags = FFTW.MEASURE</code> for better performance), and the single-threaded Astropy implementation.  (Julia version: 1.6.0; <code>LombScargle.jl</code> version: 1.0.0; Python version: 3.8.6; Astropy version: 4.1.  CPU: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz.)</p><p><img src="benchmarks.png" alt="image"/></p><p>Note that this comparison is unfair, as Astropy doesn’t support pre-planning a periodogram nor multi-threading, and it pads vectors for FFT to a length which is a power of 2, while by default <code>LombScargle.jl</code> uses length which are multiples of 2, 3, 5, 7.  A non-planned periodogram in single thread mode in <code>LombScargle.jl</code> is still twice as fast as Astropy.</p><h2 id="Development"><a class="docs-heading-anchor" href="#Development">Development</a><a id="Development-1"></a><a class="docs-heading-anchor-permalink" href="#Development" title="Permalink"></a></h2><p>The package is developed at <a href="https://github.com/JuliaAstro/LombScargle.jl">https://github.com/JuliaAstro/LombScargle.jl</a>. There you can submit bug reports, make suggestions, and propose pull requests.</p><h3 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h3><p>The ChangeLog of the package is available in <a href="https://github.com/JuliaAstro/LombScargle.jl/blob/master/NEWS.md">NEWS.md</a> file in top directory.</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><p>The <code>LombScargle.jl</code> package is licensed under the BSD 3-clause &quot;New&quot; or &quot;Revised&quot; License. The original author is Mosè Giordano.</p><h3 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h3><p>This package adapts the implementation in Astropy of the the fast Lomb–Scargle method by <a href="#PR89">Press and Rybicki (1989)</a>. We claim no endorsement nor promotion by the Astropy Team.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><ul><li><div id="CUM04">Cumming, A. (2004). <em>Detectability of extrasolar planets in radial velocity surveys</em>. <a href="https://doi.org/10.1111/j.1365-2966.2004.08275.x">Monthly Notices of the Royal Astronomical Society <strong>354</strong>, 1165–1176</a>, <a href="https://arxiv.org/abs/astro-ph/0408470">arXiv:astro-ph/0408470 [astro-ph]</a>.</div></li><li><div id="CMB99">Cumming, A.; Marcy, G. W. and Butler, R. P. (1999). <em>The Lick Planet Search: Detectability and Mass Thresholds</em>. <a href="https://doi.org/10.1086/308020">The Astrophysical Journal <strong>526</strong>, 890–915</a>, <a href="https://arxiv.org/abs/astro-ph/9906466">arXiv:astro-ph/9906466 [astro-ph]</a>.</div></li><li><div id="HB86">Horne, J. and Baliunas, S. (1986). <em>A Prescription for Period Analysis of Unevenly Sampled Time Series</em>. <a href="https://doi.org/10.1086/164037">The Astrophysical Journal <strong>302</strong>, 757</a>.</div></li><li><div id="LOM76">Lomb, N. (1976). <em>Least-Squares Frequency Analysis of Unequally Spaced Data</em>. <a href="https://doi.org/10.1007/BF00648343">Astrophysics and Space Science <strong>39</strong>, 447–462</a>.</div></li><li><div id="MHC93">Murdoch, K. A.; Hearnshaw, J. and Clark, M. (1993). <em>A Search for Substellar Companions to Southern Solar-Type Stars</em>. <a href="https://doi.org/10.1086/173003">The Astrophysical Journal <strong>413</strong>, 349</a>.</div></li><li><div id="PR89">Press, W. H. and Rybicki, G. B. (1989). <em>Fast Algorithm for Spectral Analysis of Unevenly Sampled Data</em>. <a href="https://doi.org/10.1086/167197">The Astrophysical Journal <strong>338</strong>, 277</a>.</div></li><li><div id="SCA82">Scargle, J. (1982). <em>Studies in astronomical time series analysis. II. Statistical aspects of spectral analysis of unevenly spaced data.</em> <a href="https://doi.org/10.1086/160554">The Astrophysical Journal <strong>263</strong>, 835–853</a>.</div></li><li><div id="SS10">Sturrock, P. A. and Scargle, J. D. (2010). <em>False-alarm Probability in Relation to Oversampled Power Spectra, with Application to Super-Kamiokande Solar Neutrino Data</em>. <a href="https://doi.org/10.1088/0004-637X/718/1/527">The Astrophysical Journal <strong>718</strong>, 527–529</a>, <a href="https://arxiv.org/abs/1006.0546">arXiv:1006.0546 [hep-ph]</a>.</div></li><li><div id="ZK09">Zechmeister, M. and Kürster, M. (2009). <em>The generalised Lomb-Scargle periodogram: A new formalism for the floating-mean and Keplerian periodograms</em>. <a href="https://doi.org/10.1051/0004-6361:200811296">Astronomy &amp; Astrophysics <strong>496</strong>, 577–584</a>, <a href="https://arxiv.org/abs/0901.2573">arXiv:0901.2573 [astro-ph.IM]</a>.</div></li></ul></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 19 June 2024 20:29">Wednesday 19 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
